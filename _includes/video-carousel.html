{% comment %}
  Video Carousel Component
  Responsive autoplay video carousel with fade transitions
  Feature: 009-video-carousel
{% endcomment %}

{% comment %}Debug: site.data.slides exists: {{ site.data.slides | size }} slides{% endcomment %}
{% if site.data.slides %}
  <section class="video-carousel" id="video-carousel" aria-label="Video carousel" data-slides-count="{{ site.data.slides | size }}">
    {% assign video_slide_count = 0 %}
    {% for slide in site.data.slides %}
      {% if slide.video and slide.headline %}
        {% assign video_slide_count = video_slide_count | plus: 1 %}
        {% assign section_link = slide.cta_link | default: slide.section_link %}
        {% if section_link %}
          <a href="{{ section_link }}" class="carousel-slide-link" data-duration="{{ slide.duration | default: 5 }}" data-slide-index="{{ video_slide_count | minus: 1 }}">
        {% else %}
          <div class="carousel-slide" data-duration="{{ slide.duration | default: 5 }}" data-slide-index="{{ video_slide_count | minus: 1 }}">
        {% endif %}
            <video 
              class="carousel-video"
              muted 
              loop 
              autoplay
              playsinline
              preload="metadata"
              {% if slide.poster %}poster="{{ slide.poster | relative_url }}"{% endif %}>
              <source src="{{ slide.video | relative_url }}" type="video/mp4">
            </video>
        {% if section_link %}
          </a>
        {% else %}
          </div>
        {% endif %}
      {% endif %}
    {% endfor %}
  </section>
  <div class="carousel-pagination" id="carousel-pagination" aria-label="Carousel pagination">
    <!-- Pagination dots will be generated by JavaScript -->
  </div>

  <style>
    /* Video Carousel Container - Card Style */
    .video-carousel {
      position: relative;
      width: 100%;
      max-width: 100%;
      height: 0;
      padding-bottom: 56.25%; /* Default 16:9 aspect ratio, will be updated by JavaScript */
      overflow: hidden;
      background-color: var(--card-bg);
      border-radius: var(--card-border-radius, 12px);
      box-shadow: var(--card-shadow, 0 1px 3px rgba(0, 0, 0, 0.08));
      border: 1px solid var(--card-border, #e0e0e0);
      margin: 0 auto;
    }

    /* Pagination Styles */
    .carousel-pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      padding: 1rem;
      margin-top: 1rem;
    }

    .carousel-pagination-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #ccc;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.3s ease;
      padding: 0;
    }

    .carousel-pagination-dot:hover {
      transform: scale(1.2);
    }

    .carousel-pagination-dot:focus {
      outline: 2px solid var(--primary, #00BFFF);
      outline-offset: 2px;
      border-radius: 50%;
    }

    .carousel-pagination-dot.active {
      background-color: var(--primary, #00BFFF);
      transform: scale(1.3);
    }

    [data-theme="dark"] .carousel-pagination-dot,
    body.dark-theme .carousel-pagination-dot {
      background-color: #666;
    }

    [data-theme="dark"] .carousel-pagination-dot.active,
    body.dark-theme .carousel-pagination-dot.active {
      background-color: var(--secondary, #00F2A9);
    }

    /* Slide Styles - Both clickable links and non-clickable divs */
    .carousel-slide,
    .carousel-slide-link {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 0.8s ease-in-out;
      z-index: 0;
      will-change: opacity;
      display: block;
      text-decoration: none;
      color: inherit;
    }

    .carousel-slide-link {
      cursor: pointer;
    }

    /* T044: Focus state for clickable carousel slides */
    .carousel-slide-link:focus {
      outline: 3px solid var(--primary, #00BFFF);
      outline-offset: -3px;
      z-index: 2;
    }

    .carousel-slide.active,
    .carousel-slide-link.active {
      opacity: 1;
      z-index: 1;
    }

    /* Video Styles */
    .carousel-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: center;
      z-index: 0;
    }

    /* Overlay for text readability - removed, no longer needed */

    /* Headline Overlay */
    .carousel-headline-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      text-align: center;
      pointer-events: none;
      width: 90%;
      max-width: 800px;
    }

    .carousel-headline {
      color: var(--carousel-text-color, #ffffff);
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      font-weight: var(--font-weight-bold, 700);
      line-height: var(--line-height-tight, 1.25);
      margin: 0;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    /* Responsive styles - height is now dynamic based on video aspect ratio */
  </style>

  <script>
    (function() {
      'use strict';

      let currentSlideIndex = 0;
      let slideTimer = null;
      let isInitialized = false;
      let isTransitioning = false; // Guard to prevent rapid-fire slide changes
      let rapidCallCount = 0; // Track rapid calls to detect loops
      let lastCallTime = 0; // Track timing of calls
      let isPaused = false; // Allow pausing the carousel
      
      // Debug flag - set to true to enable verbose logging
      const DEBUG = false;
      
      // Safety: Stop carousel if too many rapid calls detected
      const MAX_RAPID_CALLS = 5;
      const RAPID_CALL_THRESHOLD = 500; // ms - calls within this time are considered "rapid"
      
      // Helper functions for conditional logging
      function debugLog(...args) {
        if (DEBUG) {
          console.log('[Video Carousel]', ...args);
        }
      }
      
      function debugWarn(...args) {
        if (DEBUG) {
          console.warn('[Video Carousel]', ...args);
        }
      }
      
      function debugError(...args) {
        // Always show errors
        console.error('[Video Carousel]', ...args);
      }
      
      function debugTrace(...args) {
        if (DEBUG) {
          console.trace('[Video Carousel]', ...args);
        }
      }

      function initializeCarousel() {
        // Prevent multiple initializations
        if (isInitialized) {
          console.warn('[Video Carousel] Already initialized, skipping');
          return;
        }
        debugLog('Initializing...');
        const carousel = document.getElementById('video-carousel');
        if (!carousel) {
          debugError('Carousel container not found!');
          return;
        }
        debugLog('Carousel container found');
        debugLog('Data slides count attribute:', carousel.getAttribute('data-slides-count'));
        debugLog('Carousel innerHTML length:', carousel.innerHTML.length);
        debugLog('Carousel innerHTML preview:', carousel.innerHTML.substring(0, 200));

        const slides = Array.from(carousel.querySelectorAll('.carousel-slide, .carousel-slide-link'));
        debugLog('Found', slides.length, 'slide(s)');
        
        // Sort slides by data-slide-index to ensure correct order
        const validSlides = slides.filter(validateSlide).sort((a, b) => {
          const indexA = parseInt(a.getAttribute('data-slide-index')) || 999;
          const indexB = parseInt(b.getAttribute('data-slide-index')) || 999;
          return indexA - indexB;
        });
        debugLog('Valid slides:', validSlides.length);
        // Always log slide order - critical for debugging
        console.log('[Video Carousel] Slide order after sort:', validSlides.map((s, i) => ({
          arrayIndex: i,
          dataIndex: s.getAttribute('data-slide-index'),
          videoSrc: s.querySelector('.carousel-video source')?.getAttribute('src'),
          isActive: s.classList.contains('active')
        })));
        
        // Ensure all slides are inactive initially and paused
        validSlides.forEach((slide, i) => {
          slide.classList.remove('active');
          const video = slide.querySelector('.carousel-video');
          if (video) {
            video.pause();
            video.currentTime = 0;
            // Remove any autoplay that might have started
            video.removeAttribute('autoplay');
          }
        });

        if (validSlides.length === 0) {
          debugWarn('No valid slides found!');
          debugLog('Debug info:', {
            totalSlides: slides.length,
            slides: slides.map((s, i) => ({
              index: i,
              hasVideo: !!s.querySelector('.carousel-video source'),
              hasHeadline: !!s.querySelector('.carousel-headline'),
              hasCTA: !!s.querySelector('.carousel-cta'),
              videoSrc: s.querySelector('.carousel-video source')?.getAttribute('src'),
              headlineText: s.querySelector('.carousel-headline')?.textContent,
              ctaHref: s.querySelector('.carousel-cta')?.getAttribute('href')
            }))
          });
          return;
        }

        if (validSlides.length === 1) {
          debugLog('Single slide mode');
          isInitialized = true;
          showSingleSlide(validSlides[0]);
          return;
        }

        debugLog('Starting carousel with', validSlides.length, 'slides');
        isInitialized = true;
        startCarousel(validSlides);
      }

      function validateSlide(slide) {
        // Note: headline and CTA are now in separate content slides above, so we only validate video
        const video = slide.querySelector('.carousel-video source');
        
        const isValid = video && video.getAttribute('src');
        
        if (!isValid) {
          console.debug('[Video Carousel] Invalid slide:', {
            hasVideo: !!video,
            videoSrc: video?.getAttribute('src'),
            slideHTML: slide.innerHTML.substring(0, 200)
          });
        }
        
        return isValid;
      }

      function showSingleSlide(slide) {
        debugLog('Showing single slide');
        slide.classList.add('active');
        // Hide pagination for single slide
        const pagination = document.getElementById('carousel-pagination');
        if (pagination) pagination.style.display = 'none';
        setupVideoAutoplay(slide);
      }

      function createPagination(totalSlides) {
        const pagination = document.getElementById('carousel-pagination');
        if (!pagination || totalSlides <= 1) {
          if (pagination) pagination.style.display = 'none';
          return;
        }
        
        pagination.innerHTML = '';
        for (let i = 0; i < totalSlides; i++) {
          const dot = document.createElement('button');
          dot.className = 'carousel-pagination-dot';
          dot.setAttribute('aria-label', `Go to slide ${i + 1}`);
          dot.setAttribute('data-slide-index', i);
          if (i === 0) {
            dot.classList.add('active');
          }
          dot.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Prevent clicks during transitions
            if (isTransitioning) {
              console.warn('[Video Carousel] Ignoring pagination click during transition');
              return;
            }
            const carousel = document.getElementById('video-carousel');
            const allSlides = Array.from(carousel.querySelectorAll('.carousel-slide, .carousel-slide-link'));
            const validSlides = allSlides.filter(validateSlide).sort((a, b) => {
              const indexA = parseInt(a.getAttribute('data-slide-index')) || 0;
              const indexB = parseInt(b.getAttribute('data-slide-index')) || 0;
              return indexA - indexB;
            });
            showSlide(i, validSlides);
          });
          pagination.appendChild(dot);
        }
      }

      function updatePagination(activeIndex, totalSlides) {
        const dots = document.querySelectorAll('.carousel-pagination-dot');
        debugLog('updatePagination called with activeIndex:', activeIndex, 'totalSlides:', totalSlides, 'dots.length:', dots.length);
        dots.forEach((dot, index) => {
          if (index === activeIndex) {
            dot.classList.add('active');
          } else {
            dot.classList.remove('active');
          }
        });
      }

      function startCarousel(slides) {
        debugLog('Starting carousel with slides:', slides.map((s, i) => ({
          arrayIndex: i,
          dataIndex: s.getAttribute('data-slide-index'),
          videoSrc: s.querySelector('.carousel-video source')?.getAttribute('src'),
          isActive: s.classList.contains('active')
        })));
        
        // Verify slides array order - check all slides, not just first
        console.log('[Video Carousel] Verifying slide order - all slides:', slides.map((s, i) => ({
          arrayIndex: i,
          dataIndex: s.getAttribute('data-slide-index'),
          videoSrc: s.querySelector('.carousel-video source')?.getAttribute('src')
        })));
        
        // Check if slides are in correct order by video filename
        // Expected order: Ethical-AI-Auditing (index 0), archive-rag (index 1), zero-knowledge-proof (index 2)
        let needsReorder = false;
        slides.forEach((slide, i) => {
          const videoSrc = slide.querySelector('.carousel-video source')?.getAttribute('src') || '';
          const dataIndex = parseInt(slide.getAttribute('data-slide-index')) || 0;
          
          // Check if video matches expected index
          if (dataIndex === 0 && !videoSrc.includes('Ethical-AI-Auditing') && !videoSrc.includes('ethical-ai-auditing')) {
            console.warn('[Video Carousel] Slide at data-slide-index 0 does not have Ethical-AI-Auditing video:', videoSrc);
            needsReorder = true;
          } else if (dataIndex === 1 && !videoSrc.includes('archive-rag') && !videoSrc.includes('Archive-RAG')) {
            console.warn('[Video Carousel] Slide at data-slide-index 1 does not have Archive-RAG video:', videoSrc);
            needsReorder = true;
          } else if (dataIndex === 2 && !videoSrc.includes('zero-knowledge-proof') && !videoSrc.includes('Zero-Knowledge-Proof')) {
            console.warn('[Video Carousel] Slide at data-slide-index 2 does not have Zero-Knowledge-Proof video:', videoSrc);
            needsReorder = true;
          }
        });
        
        if (needsReorder) {
          console.warn('[Video Carousel] Slide order mismatch detected - slides may be out of order');
        }
        
        // Pause all videos initially and ensure none are active
        slides.forEach((slide, i) => {
          slide.classList.remove('active');
          const video = slide.querySelector('.carousel-video');
          if (video) {
            video.pause();
            video.currentTime = 0;
            // Ensure autoplay is not set
            video.removeAttribute('autoplay');
            debugLog('Paused and reset video', i, video.querySelector('source')?.getAttribute('src'));
          }
        });
        
        // Create pagination
        createPagination(slides.length);
        
        // Reset current slide index to 0 and show first slide (index 0)
        // Ensure we're starting with the first slide in the sorted array
        currentSlideIndex = -1; // Set to -1 so showSlide knows this is the initial call
        console.log('[Video Carousel] About to show first slide (index 0)');
        console.log('[Video Carousel] First slide video:', slides[0]?.querySelector('.carousel-video source')?.getAttribute('src'));
        showSlide(0, slides);
      }

      function showSlide(index, slides) {
        // Safety: If carousel is paused, don't proceed
        if (isPaused) {
          console.warn('[Video Carousel] Carousel is paused - ignoring showSlide call');
          return;
        }
        
        // Safety: Detect rapid calls (potential infinite loop)
        const now = Date.now();
        if (now - lastCallTime < RAPID_CALL_THRESHOLD) {
          rapidCallCount++;
          if (rapidCallCount >= MAX_RAPID_CALLS) {
            console.error('[Video Carousel] ========================================');
            console.error('[Video Carousel] INFINITE LOOP DETECTED!');
            console.error('[Video Carousel] Stopping carousel to prevent browser crash');
            console.error('[Video Carousel] Rapid calls detected:', rapidCallCount);
            console.error('[Video Carousel] Current slide:', currentSlideIndex, 'Requested:', index);
            console.error('[Video Carousel] isTransitioning:', isTransitioning);
            console.error('[Video Carousel] slideTimer:', slideTimer ? 'active' : 'null');
            console.trace('[Video Carousel] STACK TRACE - THIS SHOWS WHAT IS CALLING showSlide:');
            console.error('[Video Carousel] ========================================');
            isPaused = true; // Pause the carousel
            // Expose function to resume: window.resumeVideoCarousel()
            window.resumeVideoCarousel = function() {
              isPaused = false;
              rapidCallCount = 0;
              lastCallTime = 0;
              console.log('[Video Carousel] Carousel resumed');
            };
            return;
          }
        } else {
          rapidCallCount = 0; // Reset counter if enough time has passed
        }
        lastCallTime = now;
        
        // Prevent rapid-fire calls - if we're already transitioning, ignore this call
        if (isTransitioning && currentSlideIndex !== -1) {
          console.warn('[Video Carousel] Already transitioning, ignoring showSlide call for index:', index);
          console.trace('[Video Carousel] Stack trace for blocked call');
          return;
        }
        
        // If already showing this slide and not initial call, ignore
        if (currentSlideIndex === index && currentSlideIndex !== -1) {
          console.warn('[Video Carousel] Already showing slide', index, '- ignoring duplicate call');
          console.trace('[Video Carousel] Stack trace for duplicate call');
          return;
        }
        
        // Always log showSlide calls - these are critical for debugging
        console.log('[Video Carousel] showSlide called with index:', index, 'currentSlideIndex:', currentSlideIndex, 'slides.length:', slides.length, 'isTransitioning:', isTransitioning, 'slideTimer:', slideTimer ? 'active' : 'null', 'rapidCallCount:', rapidCallCount);
        console.trace('[Video Carousel] Stack trace for showSlide call - THIS WILL SHOW WHAT IS CALLING IT');
        console.log('[Video Carousel] Slides array:', slides.map((s, i) => ({
          arrayIndex: i,
          dataIndex: s.getAttribute('data-slide-index'),
          videoSrc: s.querySelector('.carousel-video source')?.getAttribute('src')
        })));
        
        // Validate index
        if (index < 0 || index >= slides.length) {
          debugError('Invalid index:', index, 'slides.length:', slides.length);
          return;
        }
        
        // If this is the initial call (currentSlideIndex === -1), ensure we're showing index 0
        if (currentSlideIndex === -1 && index !== 0) {
          console.warn('[Video Carousel] Initial call should be index 0, but got', index, '- forcing index 0');
          index = 0;
        }
        
        // Set transitioning flag BEFORE any async operations
        isTransitioning = true;
        
        // Pause and reset ALL slides first (except the one we're about to show)
        slides.forEach((s, i) => {
          if (i !== index) {
            s.classList.remove('active');
            const v = s.querySelector('.carousel-video');
            if (v) {
              v.pause();
              v.currentTime = 0;
            }
          }
        });

        // Pause and reset previous slide's video if different from new index
        if (currentSlideIndex >= 0 && currentSlideIndex < slides.length && currentSlideIndex !== index) {
          const prevSlide = slides[currentSlideIndex];
          prevSlide.classList.remove('active');
          const prevVideo = prevSlide.querySelector('.carousel-video');
          if (prevVideo) {
            prevVideo.pause();
            prevVideo.currentTime = 0;
            debugLog('Paused previous slide', currentSlideIndex, prevVideo.querySelector('source')?.getAttribute('src'));
          }
        }

        // Find the slide by data-slide-index, not array index (since slides are sorted)
        // The 'index' parameter represents the desired data-slide-index, not the array position
        let slide = null;
        let actualArrayIndex = -1;
        
        // First, try to find slide by matching data-slide-index
        console.log('[Video Carousel] Searching for slide with data-slide-index', index, 'in', slides.length, 'slides');
        slides.forEach((s, i) => {
          const dataIndexAttr = s.getAttribute('data-slide-index');
          const slideDataIndex = parseInt(dataIndexAttr);
          console.log('[Video Carousel] Checking slide at array index', i, '- data-slide-index attribute:', dataIndexAttr, 'parsed:', slideDataIndex, 'matches?', (!isNaN(slideDataIndex) && slideDataIndex === index));
          if (!isNaN(slideDataIndex) && slideDataIndex === index) {
            slide = s;
            actualArrayIndex = i;
            console.log('[Video Carousel] âœ“ Found slide with data-slide-index', index, 'at array index', i);
          }
        });
        
        // Fallback: if not found by data-slide-index, use array index (for backwards compatibility)
        if (!slide && index >= 0 && index < slides.length) {
          slide = slides[index];
          actualArrayIndex = index;
          const fallbackDataIndex = parseInt(slide.getAttribute('data-slide-index'));
          console.warn('[Video Carousel] Slide not found by data-slide-index', index, '- using array index', index, 'which has data-slide-index', fallbackDataIndex);
        }
        
        if (!slide) {
          debugError('Slide with data-slide-index', index, 'not found in', slides.length, 'slides');
          console.log('[Video Carousel] Available slides:', slides.map((s, i) => ({
            arrayIndex: i,
            dataIndex: s.getAttribute('data-slide-index'),
            videoSrc: s.querySelector('.carousel-video source')?.getAttribute('src')
          })));
          return;
        }
        
        // Update currentSlideIndex to the actual array index for nextSlide() to work correctly
        // Also store the data-slide-index for timer checks
        currentSlideIndex = actualArrayIndex;
        const foundDataIndex = parseInt(slide.getAttribute('data-slide-index'));
        
        slide.classList.add('active');
        const videoSrc = slide.querySelector('.carousel-video source')?.getAttribute('src');
        // Always log which slide is being shown - critical for debugging
        console.log('[Video Carousel] Showing slide - requested data-slide-index:', index, 'actual array index:', actualArrayIndex, 'Video:', videoSrc);

        // Get the actual data-slide-index from the slide element
        const slideDataIndex = parseInt(slide.getAttribute('data-slide-index')) || index;
        console.log('[Video Carousel] Slide data-slide-index:', slideDataIndex, 'array index:', actualArrayIndex);

        // Play the current slide's video
        const video = slide.querySelector('.carousel-video');
        if (video) {
          setupVideoAutoplay(slide);
        }

        // Update pagination - but don't trigger clicks
        updatePagination(index, slides.length);

        // Clear any existing timer before setting a new one
        clearTimeout(slideTimer);
        slideTimer = null;
        
        // Only start timer if we have multiple slides
        if (slides.length > 1) {
          // Duration is in seconds in YAML, convert to milliseconds
          const durationSeconds = parseInt(slide.dataset.duration) || 5;
          const duration = durationSeconds * 1000; // Convert to milliseconds
          console.log('[Video Carousel] Starting timer for', durationSeconds, 'seconds (', duration, 'ms) for slide with data-slide-index', foundDataIndex);
          // Keep isTransitioning true until timer fires
          // Store the data-slide-index for the timer check (not array index)
          const timerDataIndex = foundDataIndex;
          slideTimer = setTimeout(() => {
            console.log('[Video Carousel] Timer expired for slide with data-slide-index', timerDataIndex, '- moving to next slide');
            // Check if we're still on the same slide by comparing data-slide-index
            const currentSlide = slides[currentSlideIndex];
            const currentDataIndex = currentSlide ? parseInt(currentSlide.getAttribute('data-slide-index')) : -1;
            if (currentDataIndex === timerDataIndex) {
              isTransitioning = false; // Reset before calling nextSlide
              nextSlide(slides);
            } else {
              console.warn('[Video Carousel] Timer expired but slide changed manually - was', timerDataIndex, 'now', currentDataIndex, '- ignoring');
              isTransitioning = false;
            }
          }, duration);
        } else {
          // Single slide - reset flag immediately
          isTransitioning = false;
        }
      }

      function nextSlide(slides) {
        // Only proceed if not already transitioning
        if (isTransitioning) {
          console.warn('[Video Carousel] nextSlide called but already transitioning - ignoring');
          return;
        }
        
        // Get the current slide's data-slide-index
        const currentSlide = slides[currentSlideIndex];
        if (!currentSlide) {
          console.error('[Video Carousel] Current slide not found at index', currentSlideIndex);
          return;
        }
        
        const currentDataIndex = parseInt(currentSlide.getAttribute('data-slide-index')) || 0;
        const nextDataIndex = (currentDataIndex + 1) % slides.length;
        
        console.log('[Video Carousel] nextSlide: current data-slide-index:', currentDataIndex, 'next data-slide-index:', nextDataIndex);
        console.log('[Video Carousel] Current slide video:', currentSlide.querySelector('.carousel-video source')?.getAttribute('src'));
        
        // Find the slide with the next data-slide-index
        let nextSlideElement = null;
        slides.forEach((s, i) => {
          const dataIndexAttr = s.getAttribute('data-slide-index');
          const slideDataIndex = parseInt(dataIndexAttr);
          if (!isNaN(slideDataIndex) && slideDataIndex === nextDataIndex) {
            nextSlideElement = s;
            console.log('[Video Carousel] Found next slide at array index', i, 'with video:', s.querySelector('.carousel-video source')?.getAttribute('src'));
          }
        });
        
        if (!nextSlideElement) {
          console.error('[Video Carousel] Next slide with data-slide-index', nextDataIndex, 'not found');
          console.log('[Video Carousel] Available slides:', slides.map((s, i) => ({
            arrayIndex: i,
            dataIndex: s.getAttribute('data-slide-index'),
            videoSrc: s.querySelector('.carousel-video source')?.getAttribute('src')
          })));
          return;
        }
        
        // Call showSlide with the data-slide-index (not array index)
        showSlide(nextDataIndex, slides);
      }

      function updateCarouselAspectRatio(video) {
        const carousel = document.getElementById('video-carousel');
        if (!carousel || !video) return;
        
        // Get video's natural dimensions
        const videoWidth = video.videoWidth || video.naturalWidth;
        const videoHeight = video.videoHeight || video.naturalHeight;
        
        if (videoWidth && videoHeight) {
          // Calculate aspect ratio percentage (height/width * 100)
          const aspectRatio = (videoHeight / videoWidth) * 100;
          carousel.style.paddingBottom = aspectRatio + '%';
          debugLog('Updated carousel aspect ratio to', aspectRatio.toFixed(2) + '%', 'based on video dimensions', videoWidth + 'x' + videoHeight);
        }
      }

      function setupVideoAutoplay(slide) {
        const video = slide.querySelector('.carousel-video');
        const playButton = slide.querySelector('.carousel-play-button');

        if (!video) {
          console.warn('[Video Carousel] No video element found in slide');
          return;
        }

        debugLog('Setting up autoplay for video:', video.querySelector('source')?.getAttribute('src'));
        
        // Update carousel aspect ratio when video metadata is loaded
        const updateAspectRatio = function() {
          updateCarouselAspectRatio(video);
        };
        
        video.addEventListener('loadedmetadata', updateAspectRatio);
        video.addEventListener('loadeddata', updateAspectRatio);
        
        // If video already has dimensions, update immediately
        if (video.videoWidth && video.videoHeight) {
          updateAspectRatio();
        }
        
        const playPromise = video.play();

        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              debugLog('Video autoplay succeeded');
              if (playButton) {
                playButton.style.display = 'none';
              }
            })
            .catch((error) => {
              debugWarn('Video autoplay blocked:', error);
              if (playButton) {
                playButton.style.display = 'block';
                playButton.addEventListener('click', function() {
                  video.play();
                  playButton.style.display = 'none';
                });
              }
            });
        }

        video.addEventListener('error', function(e) {
          debugError('Video error:', e);
          debugError('Video src:', video.querySelector('source')?.getAttribute('src'));
          if (playButton) {
            playButton.style.display = 'block';
          }
        });

        video.addEventListener('play', function() {
          debugLog('Video started playing');
          if (playButton) {
            playButton.style.display = 'none';
          }
        });

        video.addEventListener('loadeddata', function() {
          debugLog('Video data loaded');
        });

        video.addEventListener('loadstart', function() {
          debugLog('Video load started');
        });
      }

      function initWhenReady() {
        debugLog('initWhenReady called, readyState:', document.readyState, 'isInitialized:', isInitialized);
        if (isInitialized) {
          debugWarn('Already initialized, skipping initWhenReady');
          return;
        }
        if (document.body && document.getElementById('video-carousel')) {
          debugLog('Elements ready, initializing...');
          initializeCarousel();
        } else if (document.readyState === 'loading') {
          debugLog('Waiting for DOMContentLoaded...');
          document.addEventListener('DOMContentLoaded', function() {
            debugLog('DOMContentLoaded fired');
            if (!isInitialized) {
              setTimeout(initializeCarousel, 100);
            }
          });
        } else {
          debugLog('Delaying initialization...');
          setTimeout(function() {
            if (!isInitialized && document.body && document.getElementById('video-carousel')) {
              initializeCarousel();
            } else if (!isInitialized) {
              console.error('[Video Carousel] Still not ready after delay:', {
                hasBody: !!document.body,
                hasCarousel: !!document.getElementById('video-carousel'),
                isInitialized: isInitialized
              });
            }
          }, 100);
        }
      }

      // Expose test function to window for debugging
      window.testVideoCarousel = function() {
        console.log('=== Video Carousel Test ===');
        console.log('Carousel element:', document.getElementById('video-carousel'));
        console.log('Slides:', document.querySelectorAll('.carousel-slide, .carousel-slide-link').length);
        console.log('Active slides:', document.querySelectorAll('.carousel-slide.active, .carousel-slide-link.active').length);
        initializeCarousel();
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initWhenReady);
      } else {
        initWhenReady();
      }
    })();
  </script>
{% endif %}

